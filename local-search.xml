<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>1103 Integer Factorization</title>
    <link href="/2021/01/13/1103-Integer-Factorization/"/>
    <url>/2021/01/13/1103-Integer-Factorization/</url>
    
    <content type="html"><![CDATA[<h1 id="1103-Integer-Factorization"><a href="#1103-Integer-Factorization" class="headerlink" title="1103 Integer Factorization"></a>1103 Integer Factorization</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/YD0TiN.png" alt="YD0TiN"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>拿题目中的数据来举例 $N = 169, K = 5, P = 2$</p><ol><li>先计算出第一个位置$n_0$的范围。$max(n_0) = \sqrt[2]{169} = 13$，因此$n_0$的范围在$13 \sim 1$（从最大值开始往后遍历）。</li><li>当$n_0 = 13$时，$N = 169 - 13^2 = 0$，因为$K = 5 &gt; 1$所以$n_0=13$不满足，当$n_0=12$时，$N = 169 - 12^2 = 25$, 此时计算$n_1$的范围,$max(n_1) = \sqrt[2]{25} = 5$,$n_1$范围$5 \sim 1$.令$n_1 = 5$</li><li>当$n_1 = 5$时，$N = 25 - 5^2 = 0$，此时$K = 5 &gt; 2$，不满足，所以令$n_1 = 4$，继续求$n_2$.</li><li>重复上面步骤，当$N == 0$ 且$n_i (i == K)$时候即找到了所有的$n_i$。</li></ol><p>通过上面总结出下面的公示。</p><p>$$<br>N_i = N_{i - 1} - n_{i}^p \qquad (0 &lt;= i &lt;= K; 1 &lt;= n_{i} &lt;= \sqrt[p]{N_{i - 1}})<br>$$</p><p>设置以下变量来存储数据</p><ul><li><code>vector&lt;int&gt; graphic;</code>: 存储$n_i$结果</li><li><code>vector&lt;int&gt; ans;</code> : 存储$Sum(n_i)$的最大值对应的$n_i$</li><li><code>vector&lt;int&gt; fact</code>: 存储$n_i^P$的所有结果，防止重复计算出现超时。</li><li><code>int maxSum;</code> : 存储$Sum(n_i)$的最大值</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans, graphic,face;<br><span class="hljs-keyword">int</span> maxSum = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> n, k, p;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> tempN, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (idx == k &amp;&amp; tempN == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 找到了结果</span><br>        <span class="hljs-keyword">if</span> (maxSum &lt; sum) &#123;<br>            maxSum = sum;<br>            ans = graphic;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tempN &lt; <span class="hljs-number">0</span> || idx &gt; k) &#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">int</span> data = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>(tempN, <span class="hljs-number">1.0</span> / p); <span class="hljs-comment">// 求出最大值,再依次计算是否满足</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = data; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= graphic[idx - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 防止当前的值大于前面的值，出现超时计算</span><br>            <span class="hljs-keyword">int</span> tempNN = tempN;<br>            tempNN -= face[i];<br>            graphic.push_back(i);<br>            sum += i;<br>            dfs(idx + <span class="hljs-number">1</span>, tempNN, sum);<br>            graphic.pop_back();<br>            sum -= i;<br>         &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;p);<br>    <span class="hljs-keyword">int</span> data = (<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>(n, <span class="hljs-number">1.0</span> / p);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= data; i++) &#123;<br>        face.push_back(<span class="hljs-built_in">pow</span>(i, p));<br>    &#125;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = data; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">int</span> tempN = n;<br>        tempN -= face[i];<br>        graphic.push_back(i);<br>        sum += i;<br>        dfs(<span class="hljs-number">1</span>, tempN, sum);<br>        graphic.pop_back();<br>        sum -= i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxSum != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d = &quot;</span>, n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; k - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d^%d + &quot;</span>, ans[i], p);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d^%d\n&quot;</span>, ans[i], p);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Impossible\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>下面面是做的三个优化，其中第一个优化解决了几个用例超时的问题。2，3优化是尝试，但是有一个用例<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="">[1]</span></a></sup>一直无法通过😭。</p><ol><li>保持$n_i &gt;= n_j （i &lt; j）$，防止超时</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = data; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">if</span> (i &lt;= graphic[idx - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 防止当前的值大于前面的值，出现超时计算</span><br><span class="hljs-keyword">int</span> tempNN = tempN;<br>tempNN -= face[i];<br>graphic.push_back(i);<br>sum += i;<br>dfs(idx + <span class="hljs-number">1</span>, tempNN, sum);<br>graphic.pop_back();<br>sum -= i;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在每次计算$n_i$的同时，也计算$Sum(n_i)$的值。当得到结果后可以直接比较是否是最佳结果。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = data; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">int</span> tempN = n;<br>tempN -= face[i];<br>graphic.push_back(i);<br>sum += i;<br>dfs(<span class="hljs-number">1</span>, tempN, sum);<br>graphic.pop_back();<br>sum -= i;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>设置<code>fact</code>变量存储$n_i^P$的结果，计算$N_j = N_{j-1} - n_i^P$直接读取$n_i^P$结果。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= data; i++) &#123;<br>face.push_back(<span class="hljs-built_in">pow</span>(i, p));<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/Y1wPoW.png" alt="一直超时"><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1097 Deduplication on a Linked List</title>
    <link href="/2021/01/13/1097-Deduplication-on-a-Linked-List-1/"/>
    <url>/2021/01/13/1097-Deduplication-on-a-Linked-List-1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>1097 Deduplication on a Linked List</title>
    <link href="/2021/01/13/1097-Deduplication-on-a-Linked-List/"/>
    <url>/2021/01/13/1097-Deduplication-on-a-Linked-List/</url>
    
    <content type="html"><![CDATA[<h1 id="1097-Deduplication-on-a-Linked-List"><a href="#1097-Deduplication-on-a-Linked-List" class="headerlink" title="1097 Deduplication on a Linked List"></a>1097 Deduplication on a Linked List</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/hpuYZC.png" alt="hpuYZC"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目的是<strong>给定一个链表，按顺序删除结点中绝对值重复的链表，并且将删除后的结点按顺序输出，然后再按序输出被删除的结点</strong></p><p>具体步骤</p><ol><li>创建一个静态链表，存储结点信息。其中使用<code>order</code>表示结点在链表中的顺序。先将所有的结点<code>order=2*maxn</code>。然后非重复的结点<code>order</code>从<code>0</code>开始，重复的结点<code>order</code>从<code>maxn + i</code>开始。</li><li>使用一个<code>isExist</code>判断结点值是否重复。</li><li>设置两个变量<code>vaildCount,removeCount</code>分别表示非重复结点和被删除结点数量。在使用<code>begin</code>遍历结点顺序的时候，分别设置结点的<code>order</code>。下面是关键代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (begin != <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">if</span> (!isExist[<span class="hljs-built_in">abs</span>(node[begin].data)]) &#123;<br>isExist[<span class="hljs-built_in">abs</span>(node[begin].data)] = <span class="hljs-literal">true</span>;<br>node[begin].order = vaildCount++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>node[begin].order = maxn + removeCount++;<br>&#125;<br>begin = node[begin].next;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>对结点按照<code>order</code>排序，无效结点<code>order=2*maxn</code>都会被排到后面。而<code>0 ~ vaildCount - 1</code>为非重复结点。<code>vaildCount ~ vaildCOunt + removeCount - 1</code>为被删除结点。</li></ol><p>⚠️会有不出现在给定链表上的结点，为无效结点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">bool</span> isExist[<span class="hljs-number">2</span> * maxn + <span class="hljs-number">1</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> address, data, next;<br>    <span class="hljs-keyword">int</span> order; <span class="hljs-comment">// 标记结点在原来数组的位置。删除的结点设置为maxn+remveCount</span><br>&#125;node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.order &lt; b.order;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(isExist, <span class="hljs-literal">false</span>,  <span class="hljs-keyword">sizeof</span>(isExist));<br>    <span class="hljs-keyword">int</span> begin, n, address, vaildCount = <span class="hljs-number">0</span>, removeCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;begin, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;node[address].data, &amp;node[address].next);<br>        node[address].address = address;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;node[i].order = <span class="hljs-number">2</span> * maxn;&#125;<br><br>    <span class="hljs-keyword">while</span> (begin != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!isExist[<span class="hljs-built_in">abs</span>(node[begin].data)]) &#123;<br>            isExist[<span class="hljs-built_in">abs</span>(node[begin].data)] = <span class="hljs-literal">true</span>;<br>            node[begin].order = vaildCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node[begin].order = maxn + removeCount++;<br>        &#125;<br>        begin = node[begin].next;<br>    &#125;<br>    sort(node, node+maxn,cmp);<br>    <span class="hljs-keyword">int</span> allCount = vaildCount + removeCount;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; allCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i != vaildCount<span class="hljs-number">-1</span> &amp;&amp; i != allCount - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, node[i].address, node[i].data, node[i + <span class="hljs-number">1</span>].address);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, node[i].address, node[i].data);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>链表</tag>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>684. 冗余连接</title>
    <link href="/2021/01/13/684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/"/>
    <url>/2021/01/13/684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="684-冗余连接"><a href="#684-冗余连接" class="headerlink" title="684. 冗余连接"></a><a href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/NfR2TK.png" alt="NfR2TK"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题考察的是<strong>并查集</strong>,假设它是一个无环图，那么边和顶点的数量是$e + 1 = v$。但是因为存在一条冗余边，因此边和顶点关系为$e=v$。</p><p>同时，在通过并查集连接两个顶点的时候，若该两个顶点已经出现在一个连通分量中，则证明该此图已经连通过，出现了环，若是没有，则连通该两点。</p><div class="note note-warning">            <p>并查集知识点参考</p><ul><li>并查集详解<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="并查集详解 ——图文解说,简单易懂">[1]</span></a></sup></li><li>《算法4》<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法4">[2]</span></a></sup></li></ul>          </div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (parent[q] != q) &#123;q = parent[q]; &#125; <span class="hljs-comment">// 找到根结点</span><br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br><br>    <span class="hljs-comment">// 加权quick-union方法，参考《算法4》</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_union</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; parent, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; weight, <span class="hljs-keyword">int</span> q, <span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> qRoot = find(parent, q), pRoot = find(parent, p);<br>        <span class="hljs-keyword">if</span> (qRoot == pRoot) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (weight[qRoot] &lt; weight[pRoot]) &#123;<br>            parent[qRoot] = pRoot;<br>            weight[pRoot] += weight[qRoot];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[pRoot] = qRoot;<br>            weight[qRoot] += weight[pRoot];<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = edges.size() + <span class="hljs-number">1</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(size)</span></span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">weight</span><span class="hljs-params">(size, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123; <span class="hljs-comment">// 初始化</span><br>            parent[i] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge: edges) &#123;<br>            <span class="hljs-keyword">int</span> p = edge[<span class="hljs-number">0</span>], q = edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (find(parent, q) != find(parent, p)) &#123;<br>                quick_union(parent, weight, q, p);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> edge;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里参考《算法4》<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法4">[2]</span></a></sup>,使用的是加权quick-union方法。经过测试时间上是有提升，但是有时候也不稳定。时间是非加权结果一样。如图测试结果</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/rHY9BU.png" alt="rHY9BU"></p><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findRedundantConnection</span>(<span class="hljs-params">self, edges: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; List[int]:</span><br>        nodesCount = <span class="hljs-built_in">len</span>(edges)<br>        parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(nodesCount + <span class="hljs-number">1</span>)) <span class="hljs-comment"># 初始化值，即 parent[i] = i</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">index: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>            <span class="hljs-keyword">while</span> index != parent[index]: index = parent[index]<br>            <span class="hljs-keyword">return</span> index<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">index1: <span class="hljs-built_in">int</span>, index2: <span class="hljs-built_in">int</span></span>):</span><br>            parent[find(index1)] = find(index2)<br><br>        <span class="hljs-keyword">for</span> node1, node2 <span class="hljs-keyword">in</span> edges:<br>            <span class="hljs-keyword">if</span> find(node1) != find(node2): <span class="hljs-comment"># 如果不再一个集合里面，则没有找到重复</span><br>                union(node1, node2)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> [node1, node2]<br><br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>以下是根据《算法4》<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法4">[2]</span></a></sup>写出的Python版本的Unin-find模板。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, N</span>):</span><br>        self.count = N<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(N))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.count<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connected</span>(<span class="hljs-params">self, p, q</span>):</span><br>        <span class="hljs-keyword">return</span> self.find(p) == self.find(q)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">self, p</span>):</span><br>        <span class="hljs-keyword">while</span> (p != self.<span class="hljs-built_in">id</span>[p]): p = self.<span class="hljs-built_in">id</span>[p]<br>        <span class="hljs-keyword">return</span> p<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">self, p, q</span>):</span><br>        p_root, q_root = self.find(p), self.find(q)<br>        <span class="hljs-keyword">if</span> p_root == q_root: <span class="hljs-keyword">return</span><br>        self.<span class="hljs-built_in">id</span>[p] = q_root<br>        self.count -= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://blog.csdn.net/liujian20150808/article/details/50848646">并查集详解 ——图文解说,简单易懂</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://m.douban.com/book/subject/19952400/">算法4</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1052 Linked List Sorting</title>
    <link href="/2021/01/12/1052-Linked-List-Sorting/"/>
    <url>/2021/01/12/1052-Linked-List-Sorting/</url>
    
    <content type="html"><![CDATA[<h1 id="1052-Linked-List-Sorting"><a href="#1052-Linked-List-Sorting" class="headerlink" title="1052 Linked List Sorting"></a>1052 Linked List Sorting</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>仔细看题，考虑周全</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/7Q2QCm.png" alt="题目"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题和之前的题目一样，使用静态数组，然后进行排序。但是排序需要注意。因为存在无效数据，所以对于无效的结点，需要将结点放到最后面，然后再根据<code>key</code>值进行排序。</p><p><code>cmp</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.flag == <span class="hljs-literal">false</span> || b.flag == <span class="hljs-literal">false</span>) &#123; <span class="hljs-comment">// 若是无效数据，就放到后面去，若数据有效，则根据key值放到前面</span><br>        <span class="hljs-keyword">return</span> a.flag &gt; b.flag;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a.key &lt; b.key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>⚠️</p><ul><li>记住有无效数据，即结点不在给定的头结点链表中，这些数据需要排除。通过设置<code>flag</code>来判断它是否存在。</li><li>需要考虑有效结点数量为0，设置<code>count</code>统计有效结点数量。</li></ul><p>下面代码是实现有效结点的统计和标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> p = head, count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span>) &#123;<br>node[p].flag = <span class="hljs-literal">true</span>;<br>count++;<br>p = node[p].next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> address, key, next, order;<br>    <span class="hljs-keyword">bool</span> flag;<br>&#125;node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.flag == <span class="hljs-literal">false</span> || b.flag == <span class="hljs-literal">false</span>) &#123; <span class="hljs-comment">// 若是无效数据，就放到后面去，若数据有效，则根据key值放到前面</span><br>        <span class="hljs-keyword">return</span> a.flag &gt; b.flag;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a.key &lt; b.key;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> head, n;<br>    <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-keyword">int</span> order = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;<br>        node[i].key = maxn;<br>        node[i].flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 过滤无效结点</span><br>    &#125;<br><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;head);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;node[address].key, &amp;node[address].next);<br>        node[address].address = address;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> p = head, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span>) &#123;<br>        node[p].flag = <span class="hljs-literal">true</span>;<br>        count++;<br>        p = node[p].next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 -1\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        n = count;<br>        sort(node, node + maxn, cmp); <span class="hljs-comment">// 按照order进行排序</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %05d\n&quot;</span>, n, node[<span class="hljs-number">0</span>].address);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, node[i].address, node[i].key, node[i + <span class="hljs-number">1</span>].address);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1\n&quot;</span>, node[n - <span class="hljs-number">1</span>].address, node[n - <span class="hljs-number">1</span>].key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>链表</tag>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1032 Sharing</title>
    <link href="/2021/01/12/1032-Sharing/"/>
    <url>/2021/01/12/1032-Sharing/</url>
    
    <content type="html"><![CDATA[<h1 id="1032-Sharing"><a href="#1032-Sharing" class="headerlink" title="1032 Sharing"></a>1032 Sharing</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/XC2jKw.png" alt="题目"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题是求链表的公共结点的首个结点地址。</p><p>⚠️这里是求<strong>公共结点的首个结点位置，而不是公共尾结点的首个结点位置。</strong></p><p>因此可以使用静态链表，在结构体中定义一个<code>flag</code>变量，表示该结点在第一个链表中出现过。</p><p>按照输入的第一个链表首地址，将第一链表的所有结点<code>flag</code>标志为<code>true</code>。</p><p>然后按照输入的第二个链表的首地址，找到第一个结点<code>flag=true</code>即为两个结点的首个公共结点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> address, next;<br>    <span class="hljs-keyword">char</span> data;<br>    <span class="hljs-keyword">bool</span> flag;<br>&#125;node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> begin_a, begin_b, n;<br>    <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;begin_a, &amp;begin_b, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%d&quot;</span>, &amp;node[address].data, &amp;node[address].next);<br>    &#125;<br>    <span class="hljs-comment">// init(node_a);</span><br>    <span class="hljs-comment">// init(node_b);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;node[i].flag = <span class="hljs-literal">false</span>;&#125;<br><br>    <span class="hljs-keyword">while</span>(begin_a != <span class="hljs-number">-1</span>) &#123;<br>        node[begin_a].flag = <span class="hljs-literal">true</span>;<br>        begin_a = node[begin_a].next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (begin_b != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node[begin_b].flag) &#123;<span class="hljs-keyword">break</span>;&#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            begin_b = node[begin_b].next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (begin_b != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>, begin_b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一开始看错了题目意思，认为是要寻找<strong>公共结尾的首地址</strong>。下面代码是找<strong>公共结尾的首地址</strong>。具体思路如下</p><ol><li>创建两个静态链表<code>node_a, node_b</code>。</li><li>分别对两个链表设置位置<code>order</code>，同时计算出它们的长度<code>len1, len2</code>。</li><li>最后对两个链表，从后往前进行对比，若找到第一个不同的结点。将他们输出进行对比，若该结点后的一样的，那就输出，若不一样，则输出-1.</li></ol><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 思路：组成两个链表，记录他们的长度，然后从后往前进行比较</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-keyword">int</span> address, next, order;<br>    <span class="hljs-keyword">char</span> data;<br>&#125;node_a[maxn], node_b[maxn], node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.order &lt; b.order;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> begin_a, begin_b, n;<br>    <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;begin_a, &amp;begin_b, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d &quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c%d&quot;</span>, &amp;node[address].data, &amp;node[address].next);<br>        node[address].address = address;<br>    &#125;<br>    <span class="hljs-comment">// init(node_a);</span><br>    <span class="hljs-comment">// init(node_b);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;node_a[i].order = maxn; node_b[i].order = maxn;&#125;<br>    <span class="hljs-keyword">int</span> len1 = <span class="hljs-number">0</span>, len2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// arrange_order(begin_a, node, node_a, len1);</span><br>    <span class="hljs-comment">// arrange_order(begin_b, node, node_b, len2);</span><br>    <span class="hljs-keyword">while</span>(begin_a != <span class="hljs-number">-1</span>) &#123;<br>        node_a[begin_a].address = node[begin_a].address;<br>        node_a[begin_a].data = node[begin_a].data;<br>        node_a[begin_a].next = node[begin_a].next;<br>        node_a[begin_a].order = len1++;<br>        begin_a = node[begin_a].next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(begin_b != <span class="hljs-number">-1</span>) &#123;<br>        node_b[begin_b].address = node[begin_b].address;<br>        node_b[begin_b].data = node[begin_b].data;<br>        node_b[begin_b].next = node[begin_b].next;<br>        node_b[begin_b].order = len2++;<br>        begin_b = node[begin_b].next;<br>    &#125;<br>    sort(node_a, node_a + maxn, cmp);<br>    sort(node_b, node_b + maxn, cmp);<br>    <span class="hljs-keyword">while</span> (len1 &gt; <span class="hljs-number">0</span> &amp;&amp; len2 &gt; <span class="hljs-number">0</span> &amp;&amp; node_a[len1 - <span class="hljs-number">1</span>].address == node_b[len2 - <span class="hljs-number">1</span>].address) &#123;<br>        len1--;<br>        len2--;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node_a[len1].address == node_b[len2].address) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>, node_a[len1].address);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>链表</tag>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1025 反转链表</title>
    <link href="/2021/01/11/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/01/11/1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1025-反转链表"><a href="#1025-反转链表" class="headerlink" title="1025 反转链表"></a>1025 反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>难度：中等</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/CSJuhH.png" alt="反转链表"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>本题看起来不难，但是和<strong>leetcode</strong>不一样，他的数据是自己输入，因此还需要构造一个数据结构来存储每个输入数据</p></blockquote><ol><li>创建一个结构体如下，存储链表。其中使用一个<code>order</code>来表示链表的顺序。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address, next, order, data;<br>&#125;node[maxn];<br></code></pre></td></tr></table></figure><ul><li>address:该结点地址</li><li>next:下一个结点地址</li><li>order:结点在链表中的顺序。初始值为<code>maxn</code></li><li>data:结点数据</li></ul><ol start="2"><li>设置一个变量<code>count</code>,根据输入的首地址<code>begin</code>，给每个结点的<code>order</code>编号。最后让<code>n=count</code>.这一步很重要，因为可能给出的数据有两个链表。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (begin_address != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 计算链表的顺序</span><br>node[begin_address].order = count++;<br>begin_address = node[begin_address].next;<br>&#125;<br>n = count; <span class="hljs-comment">// 这里需要处理一下，有时候会出现两个结点。部分用例无法通过</span><br>sort(node, node + maxn, cmp); <span class="hljs-comment">// 按照链表顺序进行排序，即有效数组都在前面。</span><br></code></pre></td></tr></table></figure><ol start="3"><li>对结点进行排序，然后分成<code>group = n / k</code>,每k个一组倒叙输出。每组的最后一个结点的<code>next</code>指向的是当前组的下一组的最后一个结点<code>address</code>。</li><li>⚠️对最后一组需要单独判断。若当前是最后一组，判断是否还存在多余的小于k的结点，若存在，对最后剩余结点正序输出。若不存在，输出<code>-1</code>。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>C++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">100010</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> address, next, order, data;<br>&#125;node[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a, Node b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.order &lt; b.order;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> begin_address, n, k;<br>    <span class="hljs-keyword">int</span> address;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;begin_address, &amp;n, &amp;k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;address);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;node[address].data, &amp;node[address].next);<br>        node[address].address = address;<br>    &#125;<br>    <span class="hljs-comment">// 初始化数组的order，方便排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxn; i++) &#123;node[i].order = maxn;&#125;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (begin_address != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 计算链表的顺序</span><br>        node[begin_address].order = count++;<br>        <span class="hljs-comment">// count++;</span><br>        begin_address = node[begin_address].next;<br>    &#125;<br>    <span class="hljs-comment">// node[begin_address].order = count; // 最后一个等于-1也要标注order</span><br>    sort(node, node + maxn, cmp); <span class="hljs-comment">// 按照链表顺序进行排序，即有效数组都在前面。</span><br>    n = count; <span class="hljs-comment">// 这里需要处理一下，有时候会出现两个节点。部分用例无法通过</span><br>    <span class="hljs-comment">// 开始按照k个一组进行倒叙输出。</span><br>    <span class="hljs-comment">// 注意每组最后一个节点的next都是下一组的最后一个节点。</span><br>    <span class="hljs-comment">// 但是若是该组的下一组节点数量小于k，即下一个节点就是最后一组的第一个节点</span><br>    <span class="hljs-comment">// 若该组本身就是最后一个节点，那么下一个节点就是-1</span><br>    <span class="hljs-keyword">int</span> group = n / k; <span class="hljs-comment">// 满足每组k个数的组的数量</span><br>    <span class="hljs-comment">// 先处理前面group组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; group; i++) &#123;<br>        <span class="hljs-comment">// 倒叙输出第i组,注意每组最后一个node不要输出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = (i + <span class="hljs-number">1</span>) * k - <span class="hljs-number">1</span>; j &gt; i * k; j--) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, node[j].address, node[j].data, node[j - <span class="hljs-number">1</span>].address);<br>        &#125;<br>        <span class="hljs-comment">// 处理最后一个node的下一个节点</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d &quot;</span>, node[i * k].address, node[i * k].data);<br>        <span class="hljs-comment">// 如果当前i是最后一组</span><br>        <span class="hljs-keyword">if</span> (i == group - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 判断是否还存在小于k的最后一组组</span><br>            <span class="hljs-keyword">if</span> (n % k == <span class="hljs-number">0</span>) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-number">-1</span>);&#125;<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 存在第group+1组</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>, node[group * k].address); <span class="hljs-comment">// 指向group+1组的第一个节点。</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = group * k; r &lt; n - <span class="hljs-number">1</span>; r++) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>, node[r].address, node[r].data, node[r + <span class="hljs-number">1</span>].address);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %d\n&quot;</span>, node[n - <span class="hljs-number">1</span>].address, node[n - <span class="hljs-number">1</span>].data, <span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果不是最后一组，那么当前组的最后一个node的next指向下一个组的最后一个节点。</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>, node[(i + <span class="hljs-number">2</span>)*k - <span class="hljs-number">1</span>].address);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>难点</p><ul><li>构造一个恰当的结构体</li><li>测试用例中存在多个<code>next = -1</code>,即多条链表,所以需要使用<code>count</code>记录有效结点，然后使用<code>n = count</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>链表</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1202. Smallest String With Swaps</title>
    <link href="/2021/01/11/1202-Smallest-String-With-Swaps/"/>
    <url>/2021/01/11/1202-Smallest-String-With-Swaps/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/">1202. Smallest String With Swaps</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/SlDQXJ.png" alt="SlDQXJ"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题主要考察连通图、将属于同一连通分量中的字符进行排序，再依次放到原来同一连通分量的位置中。</p><p>方法</p><ul><li><input checked="" disabled="" type="checkbox"> DFS</li><li><input checked="" disabled="" type="checkbox"> BFS</li><li><input disabled="" type="checkbox"> Union-find</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">self, connect_graphic, graphic, visited, idx</span>):</span><br>        visited[idx] = <span class="hljs-literal">True</span><br>        connect_graphic.append(idx) <span class="hljs-comment"># 添加当前属于同一个连通图的对象</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> graphic[idx]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                self.dfs(connect_graphic, graphic, visited, i)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smallestStringWithSwaps</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, pairs: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; str:</span><br>        <span class="hljs-comment"># 思路：同一个连通图內的字符按照顺序排序，再放回原来的位置</span><br>        size = <span class="hljs-built_in">len</span>(s)<br>        graphic = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        <span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> pairs: <span class="hljs-comment"># 建图</span><br>            graphic[i].append(j)<br>            graphic[j].append(i)<br>        print(graphic)<br>        visited = [<span class="hljs-literal">False</span>] * size<br>        res = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                connect_graphic = []<br>                self.dfs(connect_graphic, graphic, visited, i)<br>                indicates = <span class="hljs-built_in">sorted</span>(connect_graphic) <span class="hljs-comment"># 索引排序</span><br>                string = <span class="hljs-built_in">sorted</span>([res[j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> indicates]) <span class="hljs-comment"># 索引对应的字符排序</span><br>                <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(indicates, string): <span class="hljs-comment"># 将对应的字符和对应的索引重现排大小</span><br>                    res[key] = val<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(res)<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度: $O(n)$,$n$为顶点的数量</li><li>空间复杂度: $O(m+n)$, $m,n$分别是图的顶点和边的数量</li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">self, connect_graphic, graphic, visited, idx</span>):</span><br>        q = collections.deque([idx])<br>        visited[idx] = <span class="hljs-literal">True</span><br>        connect_graphic.append(idx)<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:<br>            node = q.popleft()<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> graphic[node]:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                    visited[i] = <span class="hljs-literal">True</span><br>                    connect_graphic.append(i)<br>                    q.append(i)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">smallestStringWithSwaps</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span>, pairs: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; str:</span><br>        <span class="hljs-comment"># 思路：同一个连通图內的字符按照顺序排序，再放回原来的位置</span><br>        size = <span class="hljs-built_in">len</span>(s)<br>        graphic = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        <span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> pairs: <span class="hljs-comment"># 建图</span><br>            graphic[i].append(j)<br>            graphic[j].append(i)<br>        print(graphic)<br>        visited = [<span class="hljs-literal">False</span>] * size<br>        res = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                connect_graphic = []<br>                <span class="hljs-comment"># self.dfs(connect_graphic, graphic, visited, i)</span><br>                self.bfs(connect_graphic, graphic, visited, i)<br>                indicates = <span class="hljs-built_in">sorted</span>(connect_graphic) <span class="hljs-comment"># 索引排序</span><br>                string = <span class="hljs-built_in">sorted</span>([res[j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> indicates]) <span class="hljs-comment"># 索引对应的字符排序</span><br>                <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(indicates, string): <span class="hljs-comment"># 将对应的字符和对应的索引重现排大小</span><br>                    res[key] = val<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(res)<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度: $O(n)$,$n$为顶点的数量</li><li>空间复杂度: $O(m+n)$, $m,n$分别是图的顶点和边的数量</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>dfs</tag>
      
      <tag>图</tag>
      
      <tag>bfs</tag>
      
      <tag>union-find</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1051 Pop Sequence</title>
    <link href="/2021/01/07/1051-Pop-Sequence/"/>
    <url>/2021/01/07/1051-Pop-Sequence/</url>
    
    <content type="html"><![CDATA[<h1 id="1051-Pop-Sequence-25分"><a href="#1051-Pop-Sequence-25分" class="headerlink" title="1051 Pop Sequence (25分)"></a>1051 Pop Sequence (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/18Xskb.png" alt="18Xskb"></p><p>本题给定一个大小为$M$的栈，然后有一堆有序序列$1,2,3,4,5…N$依次入栈出栈。给定$K$个出栈序列，判断这几个出栈序列是否合法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建立一个栈，模拟$1 ~ N$进栈的过程，在这个过程中，将进栈的元素（<strong>栈顶元素</strong>）与当前<strong>出栈序列</strong>中的元素进行对比。若相等，则弹出栈顶，同时<strong>出栈序列</strong>往后移一位，继续此操作，直到有不相等的元素时，再让下一个元素进栈。</p><ol><li>建立一个初始的栈，该栈在每次输入前需要清空。</li><li>设置一个变量<code>flag</code>，若当前入栈后，栈的大小超过了<code>M</code>，则直接<code>flag = false;</code>然后跳出♻️。</li><li>接下然反复判断栈顶元素和当前第<code>idx</code>个<strong>出栈序列</strong>是否一样，若一样，执行弹出操作和<code>idx++</code></li><li>最后当栈为空且<code>flag=true</code>的时候输出<code>YES</code>,否则输出<code>No</code></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stack&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1001</span>;<br><span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; st;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> arr[maxn], m, n, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;n, &amp;k);<br>    <span class="hljs-keyword">while</span> (k--) &#123;<br>        <span class="hljs-keyword">while</span> (!st.empty()) &#123;st.pop();&#125; <span class="hljs-comment">// 每次都要清空栈</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>; <span class="hljs-comment">// 输出数组的下标</span><br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            st.push(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 把数字i+1压入栈</span><br>            <span class="hljs-keyword">if</span> (st.size() &gt; m) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!st.empty() &amp;&amp; st.top() == arr[idx]) &#123;<br>                st.pop();<br>                idx++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (st.empty() &amp;&amp; flag) &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);&#125;<br>        <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度分析</p><ul><li>时间复杂度：$O(n+m)$</li><li>空间复杂度: $O(max(m,n))$</li></ul>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>547. Number of Provinces</title>
    <link href="/2021/01/07/547-Number-of-Provinces/"/>
    <url>/2021/01/07/547-Number-of-Provinces/</url>
    
    <content type="html"><![CDATA[<h1 id="547-Number-of-Provinces"><a href="#547-Number-of-Provinces" class="headerlink" title="547. Number of Provinces"></a><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. Number of Provinces</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><div class="note note-warning">            <p>难度：中等</p>          </div><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/xmxR4o.png" alt="xmxR4o"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题转化为图，其大概意思就是是<strong>给出一个用邻接矩阵表示的无向图，找出连通分量的数量</strong>。</p><p>解决问题的方法主要有三种方法</p><ol><li><ul><li><input checked="" disabled="" type="checkbox"> DFS</li></ul></li><li><ul><li><input checked="" disabled="" type="checkbox"> BFS</li></ul></li><li><ul><li><input checked="" disabled="" type="checkbox"> union-ﬁnd</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p><strong>Python</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findCircleNum</span>(<span class="hljs-params">self, isConnected: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; int:</span><br>        <span class="hljs-comment"># 求连通图的数量</span><br>        size = <span class="hljs-built_in">len</span>(isConnected)<br>        visited = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        count = <span class="hljs-number">0</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">isConnected, idx</span>):</span><br>            visited[idx] = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>                <span class="hljs-keyword">if</span> isConnected[idx][i] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> visited[i]:<br>                    dfs(isConnected, i)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> visited[i]:<br>                dfs(isConnected, i)<br>                count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure><p><strong>C++</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size = isConnected.size();<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(size, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                dfs(isConnected, i, visited, size);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; isConnected, <span class="hljs-keyword">int</span> idx, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&amp; visited, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        visited[idx] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span> (isConnected[idx][i] == <span class="hljs-number">1</span> &amp;&amp; !visited[i]) &#123;<br>                dfs(isConnected, i, visited, size);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度: $O(n^2)$,这里需要对矩阵进行遍历。</li><li>空间复杂度: $O(n)$, 使用<code>visited</code>存储<code>n</code>个城市是否被访问。</li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p><strong>C++</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">class Solution &#123;<br>public:<br>    <span class="hljs-built_in">int</span> findCircleNum(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; isConnected) &#123;<br>        <span class="hljs-built_in">int</span> size = isConnected.size();<br>        <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-built_in">bool</span>&gt; visited(size, false);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>                bfs(isConnected, i, visited, size);<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br><br>    void bfs(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; isConnected, <span class="hljs-built_in">int</span> idx, vector&lt;<span class="hljs-built_in">bool</span>&gt;&amp; visited, <span class="hljs-built_in">int</span> size) &#123;<br>        visited[idx] = true;<br>        queue&lt;<span class="hljs-built_in">int</span>&gt; q;<br>        q.push(idx);<br>        <span class="hljs-keyword">while</span> (!q.empty()) &#123;<br>            <span class="hljs-built_in">int</span> node = q.front();<br>            q.pop();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-keyword">if</span> (isConnected[node][i] == <span class="hljs-number">1</span> &amp;&amp; !visited[i]) &#123;<br>                    visited[i] = true;<br>                    q.push(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从上面可以看到，<code>BFS</code>和<code>DFS</code>的写法，只有计算连通分量的时候不一样，其他都是一样的。</p><p>复杂度分析</p><ul><li>时间复杂度：$O(n^2)$，遍历整个矩阵</li><li>空间复杂度: $O(n)$.visited大小的空间</li></ul><h3 id="union-find"><a href="#union-find" class="headerlink" title="union-find"></a>union-find</h3><p>Python</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findCircleNum</span>(<span class="hljs-params">self, isConnected: List[List[<span class="hljs-built_in">int</span>]]</span>) -&gt; int:</span><br>        size = <span class="hljs-built_in">len</span>(isConnected)<br>        parent = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(size)) <span class="hljs-comment"># 初始化</span><br>        count = size <span class="hljs-comment"># 连通分量数量</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span>(<span class="hljs-params">p</span>):</span> <span class="hljs-comment"># 找到结点p</span><br>            <span class="hljs-keyword">while</span> p != parent[p]: p = parent[p]<br>            <span class="hljs-keyword">return</span> p<br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span>(<span class="hljs-params">p, q</span>):</span><br>            <span class="hljs-keyword">nonlocal</span> count<br>            parent[find(p)] = find(q)<br>            count -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size):<br>                <span class="hljs-keyword">if</span> isConnected[i][j] == <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">if</span> find(i) != find(j):<br>                        union(i,j)<br>        <span class="hljs-keyword">return</span> count<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>dfs</tag>
      
      <tag>图</tag>
      
      <tag>bfs</tag>
      
      <tag>union-find</tag>
      
      <tag>leetcode</tag>
      
      <tag>无向图</tag>
      
      <tag>邻接矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1071 Speech Patterns</title>
    <link href="/2021/01/05/1071-Speech-Patterns/"/>
    <url>/2021/01/05/1071-Speech-Patterns/</url>
    
    <content type="html"><![CDATA[<h1 id="1071-Speech-Patterns-25分"><a href="#1071-Speech-Patterns-25分" class="headerlink" title="1071 Speech Patterns (25分)"></a>1071 Speech Patterns (25分)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/dMgnxy.png" alt="dMgnxy"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目的是<strong>在一句话中，找到出现次数最多的有效单词</strong>。有效单词的定义是：包含<code>[0-9 a-z A-Z]</code>。因此本题分两步。</p><ul><li>分割出有效单词。大写字符要转成小写字母，无效字符使用<code>while</code>过滤。</li><li>使用<code>map</code>统计有效单词出现次数。</li><li>⚠️题目要求如果两个单词的数量一样，则输出字典上小的那个单词。而<code>C++</code>中<strong>map会以键从小到大的顺序自动排序</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法笔记上机训练实战指南">[1]</span></a></sup>。所以下面这个关键代码对比的时候，使用<code>it-&gt;second &gt; macCount</code>就可以求出字典上小的那个单词。如果要求出字典顺序最大的那个单词，只需要<code>it-&gt;second &gt;= maxCount</code>就可以。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it) &#123;<br><span class="hljs-keyword">if</span> (it-&gt;second &gt; maxCount) &#123;<br>maxCount = it-&gt;second;<br>ans = it-&gt;first;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 1. 分割字符串</span><br><span class="hljs-comment">// 2. 找出最大的值</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isVaildChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (c &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; mp; <span class="hljs-comment">// 统计字符的数量</span><br>    <span class="hljs-built_in">string</span> str, ans;<br>    getline(<span class="hljs-built_in">cin</span>, str);<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>, size = str.length(), maxCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (idx &lt; size) &#123; <span class="hljs-comment">// 开始分割字符串</span><br>        <span class="hljs-built_in">string</span> word;<br>        <span class="hljs-comment">// 1. 判断当前字符是否有效</span><br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; isVaildChar(str[idx])) &#123; <span class="hljs-comment">// 如果该字符有效</span><br>            <span class="hljs-keyword">if</span> (str[idx] &gt;=<span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; str[idx] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;str[idx] += <span class="hljs-number">32</span>;&#125;<br>            word += str[idx];<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (word != <span class="hljs-string">&quot;&quot;</span>) &#123; <span class="hljs-comment">// 如果该字符不是空的，就加入到map中</span><br>            <span class="hljs-keyword">if</span> (mp.find(word) != mp.end()) &#123;mp[word]++;&#125;<br>            <span class="hljs-keyword">else</span> &#123;mp[word] = <span class="hljs-number">1</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (idx &lt; size &amp;&amp; !isVaildChar(str[idx])) &#123;idx++;&#125; <span class="hljs-comment">// 排除无效字符</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); ++it) &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;second &gt; maxCount) &#123;<br>            maxCount = it-&gt;second;<br>            ans = it-&gt;first;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; maxCount &lt;&lt;<span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/30162908/">算法笔记上机训练实战指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1054 The Dominant Color</title>
    <link href="/2021/01/05/1054-The-Dominant-Color/"/>
    <url>/2021/01/05/1054-The-Dominant-Color/</url>
    
    <content type="html"><![CDATA[<h1 id="1054-The-Dominant-Color-20分"><a href="#1054-The-Dominant-Color-20分" class="headerlink" title="1054 The Dominant Color (20分)"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805422639136768">1054 The Dominant Color (20分)</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/To7ZZS.png" alt="content"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题目目的是要找到<strong>出现次数大于总数一半的那个数字</strong>。</p><ul><li>最简单的方法就是使用<code>map</code>，以每个值作为<code>key</code>，出现次数作为<code>value</code>。再找出<code>value</code>最大的<code>key</code>。见方法一。</li><li>因为题目要求过半数的值，因此可以采用<strong>两两不相同相互抵消的方法</strong>，最后剩下的那个数一定是超过半数的数字。设置一个<code>ans</code>来存储当前数字，<code>count</code>来计算当前数字的数量。如果遇到相同的数字，<code>count++</code>,否则<code>count--</code>。若<code>count==0</code>，则令<code>ans</code>等于新的值。见方法二。</li><li>❌也可以使用一个很大的数组来存储，但是使用数组会超时</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找出最主要的颜色，即数量超过一半的</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; colors;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, num;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>            <span class="hljs-keyword">if</span> (colors.find(num) != colors.end()) &#123;<br>                colors[num]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                colors[num] = <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;::iterator it = colors.begin(); it != colors.end(); it++) &#123;<br>        <span class="hljs-keyword">if</span> (it-&gt;second &gt; max) &#123;<br>            k = it-&gt;first;<br>            max = it-&gt;second;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, k);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度</p><blockquote><p><code>map</code>的<code>find</code>时间复杂度是$O(logN)$,而遍历一遍<code>map</code>的时间复杂度是$O(N)$。因此总的时间复杂度是 $O(N*logN)$</p></blockquote><p>空间复杂度</p><blockquote><p>$O (N)$</p></blockquote><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 找出最主要的颜色，即数量超过一半的</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, m, ans = <span class="hljs-number">0</span>, count = <span class="hljs-number">1</span>, num;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>            <span class="hljs-keyword">if</span> (ans == num) count++; <span class="hljs-comment">// 遇到相同的数字，则count++</span><br>            <span class="hljs-keyword">else</span> count--;<br>            <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 令ans等于新的值</span><br>                ans = num;<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度</p><blockquote><p>$O(N)$</p></blockquote><p>空间复杂度</p><blockquote><p>$O(1)$</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p>C++知识学习</p></blockquote><ul><li><code>map</code>遍历以及对key,value的访问</li></ul><p><code>map</code>使用迭代器进行遍历元素<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法笔记上机训练实战指南">[1]</span></a></sup></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it;<br>it-&gt;first; <span class="hljs-comment">// 访问key</span><br>it-&gt;second; <span class="hljs-comment">// 访问value</span><br><span class="hljs-comment">// 遍历每个元素</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;::iterator it = mp.begin(); it != mp.end(); it++) &#123;<br><span class="hljs-keyword">int</span> key = it-&gt;first;<br><span class="hljs-keyword">int</span> value = it-&gt;second;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>map</code>判断<code>key</code>是否存在<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++(14):判断map中key值是否存在">[2]</span></a></sup></li></ul><p><strong>find函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">iterator <span class="hljs-title">find</span> <span class="hljs-params">( <span class="hljs-keyword">const</span> key_type&amp; key )</span></span>;<br></code></pre></td></tr></table></figure><p>如果key存在，则find返回key对应的迭代器，如果key不存在，则find返回尾后迭代器 .end()。可以参考下面的示例来判断key值是否存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (mp.find(key) == mp.end()) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mp not has the key&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mp has the key&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/30162908/">算法笔记上机训练实战指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/Leo_csdn_/article/details/85066264">C++(14):判断map中key值是否存在</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1044 火星数字</title>
    <link href="/2021/01/04/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/"/>
    <url>/2021/01/04/1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="1044-火星数字-20分"><a href="#1044-火星数字-20分" class="headerlink" title="1044 火星数字 (20分)"></a><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805279328157696">1044 火星数字 (20分)</a></h1><blockquote><p>本文内容参考自《算法笔记-上机训练实战指南》<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="算法笔记上机训练实战指南">[1]</span></a></sup>，并添加上自己总结，容易出错部分。</p></blockquote><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>火星人是以 13 进制计数的：</p><ul><li>地球人的 0 被火星人称为 tret。</li><li>地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。</li><li>火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。</li></ul><p>例如地球人的数字 <code>29</code> 翻译成火星文就是 <code>hel mar</code>；而火星文 <code>elo nov</code> 对应地球数字 <code>115</code>。为了方便交流，请你编写程序实现地球和火星数字之间的互译。</p><p>输入格式：<br>输入第一行给出一个正整数 $N（&lt;100）$，随后 $N$ 行，每行给出一个 $[0, 169)$ 区间内的数字 —— 或者是地球文，或者是火星文。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>对应输入的每一行，在一行中输出翻译后的另一种语言的数字。</p><blockquote><p>4</p><p>29</p><p>5</p><p>elo nov</p><p>tam</p></blockquote><h2 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h2><blockquote><p>hel mar</p><p>may</p><p>115</p><p>13</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>因为输入的测试数据范围是$13*13=169$，所以可以考虑将所有数据都计算出来。</li><li>设置两个数组，一个是<code>n2s</code>，用来存储数字转化为字符串。</li><li>另一个数组 <code>s2n</code>，用来存储字符串转化为数字。</li></ul><p>预处理代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">string</span> unit[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;jan&quot;</span>, <span class="hljs-string">&quot;feb&quot;</span>, <span class="hljs-string">&quot;mar&quot;</span>, <span class="hljs-string">&quot;apr&quot;</span>, <span class="hljs-string">&quot;may&quot;</span>, <span class="hljs-string">&quot;jun&quot;</span>, <span class="hljs-string">&quot;jly&quot;</span>, <span class="hljs-string">&quot;aug&quot;</span>, <span class="hljs-string">&quot;sep&quot;</span>, <span class="hljs-string">&quot;oct&quot;</span>, <span class="hljs-string">&quot;nov&quot;</span>, <span class="hljs-string">&quot;dec&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> ten[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;tam&quot;</span>, <span class="hljs-string">&quot;hel&quot;</span>, <span class="hljs-string">&quot;maa&quot;</span>, <span class="hljs-string">&quot;huh&quot;</span>, <span class="hljs-string">&quot;tou&quot;</span>, <span class="hljs-string">&quot;kes&quot;</span>, <span class="hljs-string">&quot;hei&quot;</span>, <span class="hljs-string">&quot;elo&quot;</span>, <span class="hljs-string">&quot;syy&quot;</span>, <span class="hljs-string">&quot;lok&quot;</span>, <span class="hljs-string">&quot;mer&quot;</span>, <span class="hljs-string">&quot;jou&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> n2s[<span class="hljs-number">170</span>]; <span class="hljs-comment">// num-&gt;string</span><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; s2n; <span class="hljs-comment">// string -&gt; num</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        n2s[i] = unit[i]; <span class="hljs-comment">// 填充 0- 12</span><br>        n2s[i * <span class="hljs-number">13</span>] = ten[i]; <span class="hljs-comment">// 填充13的倍数</span><br>        s2n[unit[i]] = i; <span class="hljs-comment">// 填充 0-12</span><br>        s2n[ten[i]] = i * <span class="hljs-number">13</span>; <span class="hljs-comment">// 填充 13的倍数</span><br><br>    &#125;<br>    <span class="hljs-comment">// 接下来填充其他部分数据</span><br><span class="hljs-comment">// ⚠️需要从1开始，因为13倍数部分已经在上面被填充了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">13</span>; ++j) &#123;<br>            <span class="hljs-built_in">string</span> res = ten[i] + <span class="hljs-string">&quot; &quot;</span> + unit[j]; <span class="hljs-comment">// 组成新的字符串</span><br>            n2s[i * <span class="hljs-number">13</span> + j] = res;<br>            s2n[res] = i * <span class="hljs-number">13</span> + j;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">string</span> unit[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;jan&quot;</span>, <span class="hljs-string">&quot;feb&quot;</span>, <span class="hljs-string">&quot;mar&quot;</span>, <span class="hljs-string">&quot;apr&quot;</span>, <span class="hljs-string">&quot;may&quot;</span>, <span class="hljs-string">&quot;jun&quot;</span>, <span class="hljs-string">&quot;jly&quot;</span>, <span class="hljs-string">&quot;aug&quot;</span>, <span class="hljs-string">&quot;sep&quot;</span>, <span class="hljs-string">&quot;oct&quot;</span>, <span class="hljs-string">&quot;nov&quot;</span>, <span class="hljs-string">&quot;dec&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> ten[<span class="hljs-number">13</span>] = &#123;<br>    <span class="hljs-string">&quot;tret&quot;</span>, <span class="hljs-string">&quot;tam&quot;</span>, <span class="hljs-string">&quot;hel&quot;</span>, <span class="hljs-string">&quot;maa&quot;</span>, <span class="hljs-string">&quot;huh&quot;</span>, <span class="hljs-string">&quot;tou&quot;</span>, <span class="hljs-string">&quot;kes&quot;</span>, <span class="hljs-string">&quot;hei&quot;</span>, <span class="hljs-string">&quot;elo&quot;</span>, <span class="hljs-string">&quot;syy&quot;</span>, <span class="hljs-string">&quot;lok&quot;</span>, <span class="hljs-string">&quot;mer&quot;</span>, <span class="hljs-string">&quot;jou&quot;</span><br>&#125;;<br><br><span class="hljs-built_in">string</span> n2s[<span class="hljs-number">170</span>]; <span class="hljs-comment">// num-&gt;string</span><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; s2n; <span class="hljs-comment">// string -&gt; num</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        n2s[i] = unit[i]; <span class="hljs-comment">// 填充 0- 12</span><br>        n2s[i * <span class="hljs-number">13</span>] = ten[i]; <span class="hljs-comment">// 填充13的倍数</span><br>        s2n[unit[i]] = i; <span class="hljs-comment">// 填充 0-12</span><br>        s2n[ten[i]] = i * <span class="hljs-number">13</span>; <span class="hljs-comment">// 填充 13的倍数</span><br><br>    &#125;<br>    <span class="hljs-comment">// 接下来填充其他部分数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">13</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">13</span>; ++j) &#123;<br>            <span class="hljs-built_in">string</span> res = ten[i] + <span class="hljs-string">&quot; &quot;</span> + unit[j]; <span class="hljs-comment">// 组成新的字符串</span><br>            n2s[i * <span class="hljs-number">13</span> + j] = res;<br>            s2n[res] = i * <span class="hljs-number">13</span> + j;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    init();<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">cin</span>.get(); <span class="hljs-comment">// 需要吸收回车符号，不然使用getline的第一个字符是回车</span><br>    <span class="hljs-keyword">while</span> (n--) &#123;<br>        <span class="hljs-built_in">string</span> str;<br>        getline(<span class="hljs-built_in">cin</span>, str);<br>        <span class="hljs-comment">// fgets(str, 100, stdin);</span><br>        <span class="hljs-comment">// cin &gt;&gt; str;</span><br>        <span class="hljs-comment">// cout &lt;&lt; str &lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; str[<span class="hljs-number">0</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); ++i)<br>            &#123;<br>                num = num * <span class="hljs-number">10</span> + (str[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <span class="hljs-comment">// printf(&quot;%d\n&quot;, num);</span><br>            <span class="hljs-comment">//printf(&quot;%s\n&quot;, n2s[num]);</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; n2s[num] &lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//printf(&quot;%d\n&quot;, s2n[str]);</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; s2n[str] &lt;&lt;<span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><blockquote><p>由于本人初次学习C++，在写代码的时候遇到几个语法问题</p></blockquote><ul><li>在输出<code>string</code>类型的变量时候，使用<code>printf(&quot;%s&quot;, str);</code>出现乱码，而需要使用<code>cout &lt;&lt; str &lt;&lt; endl;</code>。因为<code>printf</code>里面要求的是<code>*char</code>类型，而<code>string</code>与<code>*char</code>类型不一样。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="c++ string问题 cout输出正常，printf输出乱码">[2]</span></a></sup></li><li>C++中，处理字符<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="C++ 输入函数getline(cin,str) 与cin.getline(str,int)区别">[3]</span></a></sup><ul><li>处理<code>string</code>使用<code>getline(cin,str)</code>.</li><li>处理<code>char[]</code>类型使用<code>cin.getline(char * , in)</code></li><li>⚠️ 在输入的时候，需要注意吸收字符<code>cin.get();//接受最后一个结束符</code></li></ul></li></ul><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://book.douban.com/subject/30162908/">算法笔记上机训练实战指南</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://blog.csdn.net/qinweixin/article/details/51743962">c++ string问题 cout输出正常，printf输出乱码</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://blog.csdn.net/xumengxing/article/details/6664436">C++ 输入函数getline(cin,str) 与cin.getline(str,int)区别</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>PAT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArcGIS For JS 实现鹰眼图</title>
    <link href="/2021/01/04/ArcGIS-For-JS-%E5%AE%9E%E7%8E%B0%E9%B9%B0%E7%9C%BC%E5%9B%BE/"/>
    <url>/2021/01/04/ArcGIS-For-JS-%E5%AE%9E%E7%8E%B0%E9%B9%B0%E7%9C%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="鹰眼图-概述图实现"><a href="#鹰眼图-概述图实现" class="headerlink" title="鹰眼图/概述图实现"></a>鹰眼图/概述图实现</h1><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/bPrbRu.png" alt="bPrbRu"></p><p>本例展示在3D场景中添加一个2D的鹰眼图/概述图。概述图展示当前所在的3D场景。使用<a href="https://developers.arcgis.com/javascript/latest/api-reference/esri-core-Accessor.html#watch">watch()</a>来实现2D概览图和3D场景图的同步。<a href="https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=overview-map">具体案例</a>。</p><blockquote><p>有关watching属性的更多信息，可以查看<a href="https://developers.arcgis.com/javascript/latest/guide/programming-patterns/#properties">Working with properties</a></p></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol><li>创建一个DIV，用来展示鹰眼图。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;overviewDiv&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;extentDiv&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>为鹰眼图创建一个Map。</li><li>为鹰眼图创建一个MapView</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> overviewMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(&#123;<br>    basemap: <span class="hljs-string">&quot;topo&quot;</span><br>&#125;)<br><br><span class="hljs-keyword">var</span> mapView = <span class="hljs-keyword">new</span> MapView(&#123;<br>    contrain: <span class="hljs-string">&quot;overviewDIV&quot;</span>,<br>    map: overviewMap,<br>    constraints: &#123;<br>        rotationEnabled: <span class="hljs-literal">false</span><br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 移除默认的MapVIew自带的控件,具体效果可看文末下面</span><br>mapView.ui.components = [];<br></code></pre></td></tr></table></figure><ol start="4"><li>创建一个灰色的矩形用来标示当前的位置，并添加到mapview中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> extent3Dgraphic = <span class="hljs-keyword">new</span> Graphic(&#123;<br>    geometry: <span class="hljs-literal">null</span>,<br>    symbol: &#123;<br>      type: <span class="hljs-string">&quot;simple-fill&quot;</span>,<br>      color: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>],<br>      outline: <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;);<br>  mapView.graphics.add(extent3Dgraphic);<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>重点：使用WatchUtils监听MainView的extent属性变化</strong></li></ol><p><strong>WatchUtils的用法</strong></p><p><code>watchUtils.init(obj, propertyName, callback)</code></p><p>具体代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">watchUtils.init(mainView, <span class="hljs-string">&quot;extent&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">extent</span>) </span>&#123;<br><span class="hljs-comment">// 当3D场景静止的时候，mapView移动到视图的位置</span><br><span class="hljs-keyword">if</span> (mainView.stationary) &#123;<br>  mapView.goTo(&#123;<br>    center: mainView.center,<br>    scale:<br>      mainView.scale *<br>      <span class="hljs-number">2</span> *<br>      <span class="hljs-built_in">Math</span>.max(<br>        mainView.width / mapView.width,<br>        mainView.height / mapView.height<br>      )<br>  &#125;);<br>&#125;<br><br>extent3Dgraphic.geometry = extent;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>mapView.ui.components = []的作用</strong></p><p>如图，该语句作用是清空默认的组件</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/LmJOlG.png" alt="LmJOlG"></p><p><strong>Scale缩放算式</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">mainView.<span class="hljs-built_in">scale</span> * <span class="hljs-number">2</span> *<br>Math.<span class="hljs-built_in">max</span>(<br>mainView.<span class="hljs-built_in">width</span> / mapView.<span class="hljs-built_in">width</span>,<br>mainView.<span class="hljs-built_in">height</span> / mapView.<span class="hljs-built_in">height</span><br></code></pre></td></tr></table></figure><p><code>mapView.width/height</code> 是指当前显示区域的宽度和高度.</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> size = mainView.<span class="hljs-built_in">scale</span> *<br>Math.<span class="hljs-built_in">max</span>(<br>mainView.<span class="hljs-built_in">width</span> / mapView.<span class="hljs-built_in">width</span>,<br>mainView.<span class="hljs-built_in">height</span> / mapView.<span class="hljs-built_in">height</span>)<br></code></pre></td></tr></table></figure><p>令上面的算式=size，下面两张图是size*1、2的效果。 可见其实size *1的效果已经不错了，但是 *2 效果可以更好。</p><p>*<em>size * 1*</em></p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/wgFEZq.png" alt="wgFEZq"></p><p>*<em>size * 2*</em></p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/sfffrS.png" alt="sfffrS"></p><p><a href="https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=overview-map">Overview Sample</a></p><h3 id="2D和3D同步切换"><a href="#2D和3D同步切换" class="headerlink" title="2D和3D同步切换"></a>2D和3D同步切换</h3><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Y3EIi3.png" alt="Y3EIi3"></p><p><a href="https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=views-synchronize">views-synchronize</a></p><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;<br>    &lt;meta<br>      name=<span class="hljs-string">&quot;viewport&quot;</span><br>      content=<span class="hljs-string">&quot;initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span><br>    /&gt;<br>    &lt;title&gt;Synchronize MapView and SceneView - <span class="hljs-number">4.14</span>&lt;/title&gt;<br><br>    &lt;style&gt;<br>      html,<br>      body &#123;<br>        padding: <span class="hljs-number">0</span>;<br>        margin: <span class="hljs-number">0</span>;<br>        height: <span class="hljs-number">100</span>%;<br>      &#125;<br>    &lt;/style&gt;<br><br>    &lt;link<br>      rel=<span class="hljs-string">&quot;stylesheet&quot;</span><br>      href=<span class="hljs-string">&quot;https://js.arcgis.com/4.14/esri/themes/light/main.css&quot;</span><br>    /&gt;<br>    &lt;script src=<span class="hljs-string">&quot;https://js.arcgis.com/4.14/&quot;</span>&gt;&lt;/script&gt;<br><br>    &lt;script&gt;<br>      <span class="hljs-built_in">require</span>([<br>        <span class="hljs-string">&quot;esri/Map&quot;</span>,<br>        <span class="hljs-string">&quot;esri/views/MapView&quot;</span>,<br>        <span class="hljs-string">&quot;esri/views/SceneView&quot;</span>,<br>        <span class="hljs-string">&quot;esri/core/watchUtils&quot;</span><br>      ], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>, MapView, SceneView, watchUtils</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(&#123;<br>          basemap: <span class="hljs-string">&quot;satellite&quot;</span><br>        &#125;);<br><br>        <span class="hljs-keyword">var</span> view1 = <span class="hljs-keyword">new</span> SceneView(&#123;<br>          id: <span class="hljs-string">&quot;view1&quot;</span>,<br>          container: <span class="hljs-string">&quot;view1Div&quot;</span>,<br>          map: map<br>        &#125;);<br><br>        <span class="hljs-keyword">var</span> view2 = <span class="hljs-keyword">new</span> MapView(&#123;<br>          id: <span class="hljs-string">&quot;view2&quot;</span>,<br>          container: <span class="hljs-string">&quot;view2Div&quot;</span>,<br>          map: map,<br>          constraints: &#123;<br>            <span class="hljs-comment">// Disable zoom snapping to get the best synchronization</span><br>            snapToZoom: <span class="hljs-literal">false</span><br>          &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * utility method that synchronizes the viewpoint of a view to other views</span><br><span class="hljs-comment">         * 同步视图</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">var</span> synchronizeView = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">view, others</span>) </span>&#123;<br>          others = <span class="hljs-built_in">Array</span>.isArray(others) ? others : [others];<br><br>          <span class="hljs-keyword">var</span> viewpointWatchHandle;<br>          <span class="hljs-keyword">var</span> viewStationaryHandle;<br>          <span class="hljs-keyword">var</span> otherInteractHandlers;<br>          <span class="hljs-keyword">var</span> scheduleId;<br><br>          <span class="hljs-keyword">var</span> clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (otherInteractHandlers) &#123;<br>              otherInteractHandlers.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handle</span>) </span>&#123;<br>                handle.remove();<br>              &#125;);<br>            &#125;<br>            <span class="hljs-comment">// 这是什么意思?</span><br>            <span class="hljs-comment">// viewpointWatchHandle 和 viewStatioaryHandle 对象是WatchHandle对象，其中有一个remove对象方法。用来清空监听属性</span><br>            viewpointWatchHandle &amp;&amp; viewpointWatchHandle.remove();<br>            viewStationaryHandle &amp;&amp; viewStationaryHandle.remove();<br>            scheduleId &amp;&amp; <span class="hljs-built_in">clearTimeout</span>(scheduleId);<br>            otherInteractHandlers = viewpointWatchHandle = viewStationaryHandle = scheduleId = <span class="hljs-literal">null</span>;<br>          &#125;;<br><br>            <span class="hljs-comment">// 监听当前控制视图的 交互和动画属性</span><br>          <span class="hljs-keyword">var</span> interactWatcher = view.watch(<span class="hljs-string">&quot;interacting,animation&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">            newValue</span></span><br><span class="hljs-function"><span class="hljs-params">          </span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (!newValue) &#123;<br>              <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (viewpointWatchHandle || scheduleId) &#123;<br>              <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 开始更新其他视图</span><br>            scheduleId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              scheduleId = <span class="hljs-literal">null</span>;<br>              <span class="hljs-comment">// 监听当前view的视点属性</span><br>              viewpointWatchHandle = view.watch(<span class="hljs-string">&quot;viewpoint&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">                newValue</span></span><br><span class="hljs-function"><span class="hljs-params">              </span>) </span>&#123;<br>                <span class="hljs-comment">// 根据新获取的视点，其他视图也同时更新它的视点</span><br>                others.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherView</span>) </span>&#123;<br>                  otherView.viewpoint = newValue;<br>                &#125;);<br>              &#125;);<br>            &#125;, <span class="hljs-number">0</span>);<br><br>            <span class="hljs-comment">// stop as soon as another view starts interacting, like if the user starts panning</span><br>            <span class="hljs-comment">// 如果移动其他视图，则销毁当前视图的所有变量</span><br>            otherInteractHandlers = others.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherView</span>) </span>&#123;<br>              <span class="hljs-keyword">return</span> watchUtils.watch(<br>                otherView,<br>                <span class="hljs-string">&quot;interacting,animation&quot;</span>,<br>                <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>                  <span class="hljs-keyword">if</span> (value) &#123;<br>                    clear();<br>                  &#125;<br>                &#125;<br>              );<br>            &#125;);<br><br>            <span class="hljs-comment">// or stop when the view is stationary again</span><br>            <span class="hljs-comment">// 当不再和视图进行交互时候，即 stationary 状态，则也注销所有变量</span><br>            <span class="hljs-comment">// 当监听的属性为True的时候执行</span><br>            viewStationaryHandle = watchUtils.whenTrue(<br>              view,<br>              <span class="hljs-string">&quot;stationary&quot;</span>,<br>              clear<br>            );<br>          &#125;);<br><br>          <span class="hljs-keyword">return</span> &#123;<br>            remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>              clear();<br>              interactWatcher.remove();<br>            &#125;<br>          &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 同步多个View的视点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">var</span> synchronizeViews = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">views</span>) </span>&#123;<br>        <span class="hljs-comment">/* array.map(function(currentValue,index,arr), thisValue)</span><br><span class="hljs-comment">        * 遍历所有的view</span><br><span class="hljs-comment">        * views.concat() 对当前对views进行复制一份</span><br><span class="hljs-comment">        * handles 存储一系列的同步事件</span><br><span class="hljs-comment">        */</span><br>          <span class="hljs-keyword">var</span> handles = views.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">view, idx, views</span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> others = views.concat(); <span class="hljs-comment">// 复制一份views</span><br>            others.splice(idx, <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除当前视图，其他视图则是others</span><br>            <span class="hljs-keyword">return</span> synchronizeView(view, others); <span class="hljs-comment">//</span><br>          &#125;);<br><br>          <span class="hljs-keyword">return</span> &#123;<br>            remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>              <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>              handles.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">h</span>) </span>&#123;<br>                h.remove();<br>              &#125;);<br>              handles = <span class="hljs-literal">null</span>;<br>            &#125;<br>          &#125;;<br>        &#125;;<br><br>        <span class="hljs-comment">// 绑定两个视图</span><br>        synchronizeViews([view1, view2]);<br>      &#125;);<br>    &lt;/script&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;div id=<span class="hljs-string">&quot;view1Div&quot;</span> style=<span class="hljs-string">&quot;float: left; width: 50%; height: 100%;&quot;</span>&gt;&lt;/div&gt;<br>    &lt;div id=<span class="hljs-string">&quot;view2Div&quot;</span> style=<span class="hljs-string">&quot;float: left; width: 50%; height: 100%;&quot;</span>&gt;&lt;/div&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ArcGIS For JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArcGIS For JS</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ceisum实现铁路仿真</title>
    <link href="/2021/01/03/Ceisum%E5%AE%9E%E7%8E%B0%E9%93%81%E8%B7%AF%E4%BB%BF%E7%9C%9F/"/>
    <url>/2021/01/03/Ceisum%E5%AE%9E%E7%8E%B0%E9%93%81%E8%B7%AF%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="铁路模拟仿真实现"><a href="#铁路模拟仿真实现" class="headerlink" title="铁路模拟仿真实现"></a>铁路模拟仿真实现</h1><p>实现效果</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/lxieypx;.gif" alt="train"></p><p>内容比较多，只讲部分内容，可能有点乱。可以参考一下代码，有不懂的欢迎提问</p><h1 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h1><p>这些变量下面都会用到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 运动车厢的速度</span><br><span class="hljs-keyword">let</span> velocity = <span class="hljs-number">30</span> <span class="hljs-comment">// 速度,根据他来计算到达各个点的时间</span><br><span class="hljs-comment">// 当前目标点的位置</span><br><span class="hljs-comment">// var currentIndex = 1</span><br><br><span class="hljs-comment">// 每节车厢相对上一节车厢延时一定时间到达同一个位置</span><br><span class="hljs-keyword">var</span> delayTime = <span class="hljs-number">13</span><br><br><span class="hljs-comment">// 存储所有运动中的实体对象</span><br><span class="hljs-keyword">var</span> dynamicEntities = []<br><br><span class="hljs-comment">// 运动模型数量</span><br><span class="hljs-keyword">var</span> dynamicNum = <span class="hljs-number">5</span><br><br><span class="hljs-comment">// 每节铁轨的长度，用于计算两个点之前铺设多少节铁轨</span><br><span class="hljs-keyword">var</span> modelLength = <span class="hljs-number">170</span><br><br><span class="hljs-comment">// 初始化dynamicEntitye</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dynamicNum ; ++i) &#123;<br>    <span class="hljs-keyword">let</span> obj = &#123;<br>        entity: <span class="hljs-literal">null</span>, <span class="hljs-comment">// 实体对象</span><br>        property: <span class="hljs-keyword">new</span> Cesium.SampledPositionProperty(), <span class="hljs-comment">// 动态位置属性</span><br>        timeAndOrientationList: [],<br>        startTime: <span class="hljs-number">0</span>,<br>        endTime: <span class="hljs-number">0</span><br>    &#125;<br>    dynamicEntities.push(obj)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="加载线路并获取位置"><a href="#加载线路并获取位置" class="headerlink" title="加载线路并获取位置"></a>加载线路并获取位置</h1><p>我们需要有一系列点路径坐标（火车运行的路径）。这里我从Google Eearth中绘制了一条线，然后导出为KML数据加载进来。</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/7MbzTG.png" alt="Google earth"></p><p>通过加载的这条路径，我们需要获取路径中每个转折点的坐标信息。通过这些转折点，我们可以完成<strong>设置铁轨位置</strong>和<strong>计算出模型实体每个时间点对应点位置</strong></p><p><strong>加载KML</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 初始化路径 设置带时间的路径</span><br>viewer.dataSources.add(Cesium.KmlDataSource.load(routerUrl,<br>    &#123;<br>        camera: viewer.scene.camera,<br>        canvas: viewer.scene.canvas,<br>        clampToGround: <span class="hljs-literal">true</span><br>    &#125;)<br>).then(<span class="hljs-function"><span class="hljs-params">dataSource</span> =&gt;</span> &#123;<br><span class="hljs-comment">// ... 加载好后获取改路径点坐标数组</span><br>    <span class="hljs-keyword">var</span> router = dataSource.entities.getById(<span class="hljs-string">&#x27;0129AA13ED12D2857AD0&#x27;</span>);<br>    <span class="hljs-keyword">var</span> positions = router.polyline.positions._value<br>    viewer.flyTo(router)<br>    <span class="hljs-comment">// createDynamicPositions(positions) // 计算带时间的路径</span><br>    <span class="hljs-comment">// createDynamicEntity() // 根据动态路径创建模型实体</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>首先我们加载好路线后，就要获取改路线的坐标数组（每个转折点或顶点的位置）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取路径对象</span><br><span class="hljs-keyword">var</span> router = dataSource.entities.getById(<span class="hljs-string">&#x27;0129AA13ED12D2857AD0&#x27;</span>);<br><span class="hljs-comment">// 获取对象中的坐标数组</span><br><span class="hljs-keyword">var</span> positions = router.polyline.positions._value<br></code></pre></td></tr></table></figure><p>我们可以看一下这些数组的内容</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/IoR5O3.png" alt="IoR5O3"></p><p>在这里可以看出来，这些坐标全是笛卡尔类型。同时可以知道我们总共有13个转折点</p><p>接下来两章是重点</p><h1 id="加载铁轨"><a href="#加载铁轨" class="headerlink" title="加载铁轨"></a>加载铁轨</h1><p>效果展示</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Kkx93r.png" alt="Kkx93r"></p><p>实现上面效果，这里我们需要做下面几步。</p><ul><li>计算每段路（两个点）之间的距离S</li><li>设置每个铁轨的固定长度L</li><li>计算每段路可以铺设多少个模型 num = S / L</li><li>通过每段路两端的点的坐标，计算出这段中每个铁轨模型的位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 这个是每个模型的长度，在一开始的时候就定义了</span><br><span class="hljs-comment">// var modelLength = 170</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">repeateModel</span>(<span class="hljs-params">posCart1, posCart2</span>) </span>&#123;<br>    <span class="hljs-comment">// 需要摆放模型的数量</span><br>    <span class="hljs-comment">// 模型的数量 = 两个点之间的长度 / 每个模型的长度</span><br>    <span class="hljs-keyword">let</span> modelNum = <span class="hljs-built_in">parseInt</span>(computeDistance(posCart1, posCart2) / modelLength)<br>    <span class="hljs-comment">// 根据两个点的经纬度调整每个模型的方向</span><br>    <span class="hljs-keyword">let</span> heading = computeOrientation(posCart1, posCart2)<br>    <span class="hljs-comment">// 开始计算每个模型的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; modelNum; ++i) &#123;<br>    <span class="hljs-comment">// 求第i个点的位置。下面有介绍为什么这样写</span><br>        <span class="hljs-keyword">var</span> mid = <span class="hljs-keyword">new</span> Cesium.Cartesian3()<br>        Cesium.Cartesian3.add(<br>            Cesium.Cartesian3.multiplyByScalar(posCart1, i / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>            Cesium.Cartesian3.multiplyByScalar(posCart2, (modelNum - i) / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>            mid<br>        )<br><span class="hljs-comment">// 计算出位置后，添加铁轨模型到Viewer中。同时调整模型的方向</span><br>        viewer.entities.add(&#123;<br>            position: mid,<br>            model: &#123;<br>                uri: modelRailwayUrl,<br>                scale: <span class="hljs-number">0.025</span><br>            &#125;,<br>            orientation: changeOrientation(mid, heading)<br>        &#125;)<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>两个坐标之前第i的位置如何求</strong></p><p>先看一下下面的一道数学题</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/bJgWdB.png" alt="bJgWdB"></p><p>通过这道题，我们就可以写出下面代码，求出第i个点的位置了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Cesium.Cartesian3.add(<br>    Cesium.Cartesian3.multiplyByScalar(posCart1, i / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>    Cesium.Cartesian3.multiplyByScalar(posCart2, (modelNum - i) / modelNum, <span class="hljs-keyword">new</span> Cesium.Cartesian3()),<br>    mid<br>)<br></code></pre></td></tr></table></figure><p><strong>模型方向问题</strong></p><p>在上面代码中。我们经常要用到一个计算模型方向和改变模型方向的函数，那么为什么要计算模型的方向呢？</p><p>我们打开铁轨模型和系统自带的一些模型。看看他们的方向</p><p>使用下面命令调出查看方向的小工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">viewer.extend(Cesium.viewerCesiumInspectorMixin);<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/EUBOGy.png" alt="EUBOGy"></p><p>可以看到，我们的模型的方向默认位置是朝向南方（红色是东方，绿色是北方）。而官网的模型方向默认是东方。根据官方对模型的描述</p><blockquote><p>By default, the model is oriented upright and facing east. Control the orientation of the model by specifying a Quaternion for the Entity.orientation property. This controls the heading, pitch, and roll of the model.</p></blockquote><p>可以看到，我们的模型方向是有问题。因此需要手动纠正。查阅很多方法，无法从模型本身入手。所以只能通过代码的方式来纠正方向。大概的思路是先计算出两个点的方向，然后在向东方偏移90度左右即可。</p><p><strong>计算方向函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeOrientation</span>(<span class="hljs-params">posCart1, posCart2</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> heading = bearing(<br>        Cesium.Cartographic.fromCartesian(posCart1).latitude,<br>        Cesium.Cartographic.fromCartesian(posCart1).longitude,<br>        Cesium.Cartographic.fromCartesian(posCart2).latitude,<br>        Cesium.Cartographic.fromCartesian(posCart2).longitude<br>    )<br>    <span class="hljs-keyword">return</span> heading<br>&#125;<br>        <span class="hljs-comment">// 计算两点之间的方向</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bearing</span>(<span class="hljs-params">startLat, startLng, destLat, destLng</span>) </span>&#123;<br>    startLat = Cesium.Math.toRadians(startLat);<br>    startLng = Cesium.Math.toRadians(startLng);<br>    destLat = Cesium.Math.toRadians(destLat);<br>    destLng = Cesium.Math.toRadians(destLng);<br><br>    <span class="hljs-keyword">let</span> y = <span class="hljs-built_in">Math</span>.sin(destLng - startLng) * <span class="hljs-built_in">Math</span>.cos(destLat);<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Math</span>.cos(startLat) * <span class="hljs-built_in">Math</span>.sin(destLat) - <span class="hljs-built_in">Math</span>.sin(startLat) * <span class="hljs-built_in">Math</span>.cos(destLat) * <span class="hljs-built_in">Math</span>.cos(destLng - startLng);<br>    <span class="hljs-keyword">let</span> brng = <span class="hljs-built_in">Math</span>.atan2(y, x);<br>    <span class="hljs-keyword">let</span> brngDgr = Cesium.Math.toDegrees(brng);<br>    <span class="hljs-keyword">return</span> (brngDgr + <span class="hljs-number">360</span>) % <span class="hljs-number">360</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>改变模型的位置</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeOrientation</span>(<span class="hljs-params">position, degree</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> heading = Cesium.Math.toRadians(degree);<br>    <span class="hljs-keyword">var</span> pitch = Cesium.Math.toRadians(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">var</span> roll = Cesium.Math.toRadians(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">var</span> orientation = Cesium.Transforms.headingPitchRollQuaternion(position, <span class="hljs-keyword">new</span> Cesium.HeadingPitchRoll(heading, pitch, roll));<br>    <span class="hljs-keyword">return</span> orientation<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="加载运动的车头和车厢"><a href="#加载运动的车头和车厢" class="headerlink" title="加载运动的车头和车厢"></a>加载运动的车头和车厢</h1><p>这里我们需要了解一个知识。<a href="https://www.jianshu.com/p/f0b47997224c">Cesium的Property机制总结</a>.<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Cesium的Property机制总结">[1]</span></a></sup>这篇文章中，我们可以看到一个属性<code>SampledPositionProperty</code>,它可以使用物体的运动。</p><p><img src="https://upload-images.jianshu.io/upload_images/80648-366b91d38f419afa.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/296/format/webp" alt="move"></p><p>它的实现代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> property = <span class="hljs-keyword">new</span> Cesium.SampledPositionProperty();<br><br>property.addSample(Cesium.JulianDate.fromIso8601(<span class="hljs-string">&#x27;2019-01-01T00:00:00.00Z&#x27;</span>),<br>    Cesium.Cartesian3.fromDegrees(-<span class="hljs-number">114.0</span>, <span class="hljs-number">40.0</span>, <span class="hljs-number">300000.0</span>));<br><br>property.addSample(Cesium.JulianDate.fromIso8601(<span class="hljs-string">&#x27;2019-01-03T00:00:00.00Z&#x27;</span>),<br>    Cesium.Cartesian3.fromDegrees(-<span class="hljs-number">114.0</span>, <span class="hljs-number">45.0</span>, <span class="hljs-number">300000.0</span>));<br><br>blueBox.position = property;<br></code></pre></td></tr></table></figure><p>它的原理是，Entity在不同的时间运动到不同的位置。因此我们的火车运动也是一样，在不同的时候运动到不同的位置即可。那么如何实现呢？</p><p>还是通过之前获取的铁轨路径数组，再计算到达每个转折点的时间。构成一个如下图所示的数据结构。</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/XzFZ1f.png" alt="XzFZ1f"></p><p>如何让模型运动起来也可以总结为下面这张图</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Eg6FPk.png" alt="Eg6FPk"></p><p>比如4点的时候在position1位置，4.30的时候在position2位置。4.50的时候在position3位置。</p><p>那么现在时间点应该如何计算</p><p>我们设置一个速度变量V，然后计算两点的距离S。那么到达下一个的时间就是</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">time</span> = S / V<br></code></pre></td></tr></table></figure><p>因此实现代码如下（伪代码）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 计算到下一个坐标所花费的时间</span><br><span class="hljs-keyword">let</span> time2Next = computeTime(datas[index], datas[index + <span class="hljs-number">1</span>])<br><span class="hljs-comment">// 计算到达改点的时刻</span><br><span class="hljs-keyword">let</span> time = totalTime + time2Next<br><span class="hljs-comment">// 将时刻+位置信息写入到模型的位置变量中</span><br>dynamicEntity.property.addSample(<br>    Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate()),<br>    position<br>)<br><span class="hljs-comment">// 计算总花费时间</span><br>totalTime += time2Next<br><br></code></pre></td></tr></table></figure><p>这里又有新的问题。</p><p>我们需要好几节车厢一起运动，如何实现呢？</p><p>使用延时启动，就是每一个车厢到达一个转折点的时间都比上一节车厢晚一段时间。如下图所示，不同的车厢在不同的时间点的位置不一样。</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/Lp33qj.png" alt="Lp33qj"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> time = totalTime + delayTime * i<br></code></pre></td></tr></table></figure><p>我们看一下实现效果,车厢是一节在一节的后面出现的</p><p><img src="https://cdn.jsdelivr.net/gh/emhui/oss@master/uPic/lxiemjmjiuxm.gif" alt="train"></p><p>通过代码实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDynamicPositions</span>(<span class="hljs-params">positions</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> length = positions.length<br>    <span class="hljs-keyword">var</span> totalTime = <span class="hljs-number">0</span><span class="hljs-comment">// 跑完全部路程的时间</span><br>    <span class="hljs-comment">// 遍历铁轨路径的每个转折点</span><br>    positions.forEach(<span class="hljs-function">(<span class="hljs-params">position, index, datas</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 在每个路径转角处创建一个Point对象</span><br>        CreatePoint(position, index)<br>        <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> &lt; length) &#123;<br>            <span class="hljs-comment">// 计算一个点到另一点需要到时间</span><br>            <span class="hljs-keyword">let</span> time2Next = computeTime(datas[index], datas[index + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment">// 计算两个转角点的方向</span><br>            <span class="hljs-keyword">let</span> orientation = computeOrientation(datas[index], datas[index + <span class="hljs-number">1</span>])<br>            <span class="hljs-comment">// 为每个车厢模型设置 时间+位置</span><br>            dynamicEntities.forEach(<span class="hljs-function">(<span class="hljs-params">dynamicEntity, i</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 这里实现了 每个模型都相对于之前都个模型延时一定时间进行启动</span><br>                <span class="hljs-keyword">let</span> time = totalTime + delayTime * i<br>                dynamicEntity.property.addSample(<br>                    Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate()),<br>                    position<br>                )<br>                <span class="hljs-comment">// 记录每个模型分别达到一个点的时间、方向、位置</span><br>                <span class="hljs-keyword">let</span> obj = &#123;<br>                    time: totalTime, <span class="hljs-comment">// 到达下一个点需要耗费的时间,它是一个数值，不是一个时间点</span><br>                    position: position,<br>                    orientation: orientation<br>                &#125;<br><br>                <span class="hljs-comment">// 计算开始时间</span><br>                <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) &#123;<br>                    dynamicEntity.startTime = Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate())<br>                &#125;<br><br>                <span class="hljs-comment">// 计算最后一个时间</span><br>                <span class="hljs-keyword">if</span> (index + <span class="hljs-number">2</span> === length) &#123;<br>                    dynamicEntity.endTime = Cesium.JulianDate.addSeconds(start, time, <span class="hljs-keyword">new</span> Cesium.JulianDate())<br>                &#125;<br>                <span class="hljs-comment">// 将计算得到的 时间+位置 属性存储到每个实体中</span><br>                dynamicEntity.timeAndOrientationList.push(obj)<br><br>            &#125;)<br><br>            totalTime += time2Next<br><br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>这里我们发现我们也计算了每个模型的方向，为什么要计算方向呢？在上面设置铁轨的时候讲到了，因为我们的模型方向默认是有点问题的。默认朝向南方，因此需要手动调整方向，我们需要自己写一个方法，判断到了转角处进行转向。（如果是模型默认朝向东方的话，则不需要使用该方法，直接使用自带的一种方法，具体方法后面再谈）</p><p>如何实现到了转角处自动转向呢？我们在刚刚上一步的时候记录了每个模型到达某个位置的时候是在是什么时间点。因此只需要判断，当前模型运行的时间是否到了转角的时间点，到了的话就开始转向，而这个方向我们同时也在上一步的时候存储到每个实体中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    time: totalTime, <span class="hljs-comment">// 到达下一个点需要耗费的时间,它是一个数值，不是一个时间点</span><br>    position: position,<br>    orientation: orientation<br>&#125;<br></code></pre></td></tr></table></figure><p>监听当前时间点并转向的代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">viewer.clock.onTick.addEventListener(<span class="hljs-function">(<span class="hljs-params">clock</span>) =&gt;</span> &#123;<br><span class="hljs-comment">// 判断每个运动的模型当前是否到了转向时间</span><br>    dynamicEntities.forEach(<span class="hljs-function"><span class="hljs-params">dynamicEntity</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 计算每个运动的模型与模型的开始时间差</span><br>        <span class="hljs-keyword">let</span> timeOffset = Cesium.JulianDate.secondsDifference(clock.currentTime, dynamicEntity.startTime);<br>        <span class="hljs-comment">// 判断是否达到转向的时间点</span><br>        dynamicEntity.timeAndOrientationList.forEach(<span class="hljs-function">(<span class="hljs-params">obj, index, array</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (timeOffset &gt;= obj.time &amp;&amp; timeOffset &lt;= array[index + <span class="hljs-number">1</span>].time) &#123;<br>                <span class="hljs-comment">// 177在第一条铁轨是一个好的角度</span><br>                dynamicEntity.entity.orientation = changeOrientation(obj.position, obj.orientation + <span class="hljs-number">180</span>)<br>            &#125;<br>        &#125;)<br>    &#125;)<br></code></pre></td></tr></table></figure><p>如果模型的方向是正确的，只需要在创建模型实体对象的时候，指定该属性即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">orientation: <span class="hljs-keyword">new</span> Cesium.VelocityOrientationProperty(dynamicEntity.property),<br></code></pre></td></tr></table></figure><p>目前还有下面问题暂时无法解决</p><ul><li>各个模型之间的衔接不好</li></ul><blockquote><p>经过测试如果模型的方向是正确的话，那么就可以解决这个问题。所以可以从模型入手，更改模型的默认方向，使它默认朝向东方，但是自己一直没有找到如何编辑GLB模型。所以暂时无解。</p></blockquote><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.jianshu.com/p/f0b47997224c">Cesium的Property机制总结</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Cesium</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Cesium</tag>
      
      <tag>铁路</tag>
      
      <tag>仿真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo注意事项</title>
    <link href="/2021/01/03/hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2021/01/03/hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p><code>hexo clean &amp;&amp; hexo d</code></p><p><del>如果使用这个命令，可能会清除<strong>CNAME</strong>文件</del></p><p>保持永久域名的方法</p><p>在<code>/source</code>目录下面建立一个文件<code>CNAME</code>,然后填入你的域名即可。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="脚注">[1]</span></a></sup></p><h2 id="hexow文件管理-lt-span-class-”hint–top-hint–rounded”-aria-label-”hexo博客文章多了怎么管理"><a href="#hexow文件管理-lt-span-class-”hint–top-hint–rounded”-aria-label-”hexo博客文章多了怎么管理" class="headerlink" title="hexow文件管理&lt;span class=”hint–top hint–rounded” aria-label=”hexo博客文章多了怎么管理"></a>hexow文件管理<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote">&lt;span class=”hint–top hint–rounded” aria-label=”hexo博客文章多了怎么管理</h2><p>“&gt;[2]</span></a></sup></p><p>默认情况下使用<code>hexo new &quot;title&quot;</code>，所有文章都存放在<code>/source/_post</code>下面。随着文章的数量变多，该目录下面都文件也会越来越多，所以我们可以将文件进行归类。</p><ul><li>自己指定文章目录</li></ul><p><a href="https://hexo.io/zh-cn/docs/commands#new">官方</a>使用下面命令可以在创建文件的同时并归类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>比如我要创建一个文件<code>hexo new -p 其他/&quot;hexo 搭建blog&quot;.md &quot;hexo 搭建blog&quot;</code>,这样会在<code>_post</code>下面创建一个<code>其他</code>的目录，并且目录的名字是<code>heox 搭建blog.md</code>.但是这种方式非常繁琐。</p><ul><li>通过年月日管理文件</li></ul><p>因此使用第二种方式，在<code>_config.yml</code>中设置</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">new_post_name:</span> <span class="hljs-symbol">:year/</span><span class="hljs-symbol">:month/</span><span class="hljs-symbol">:title</span>.md<br></code></pre></td></tr></table></figure><p>通过这样的设置，仍使用之前创建文件的命令</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;hexo文件管理&quot;</span><br></code></pre></td></tr></table></figure><p>运行该命令则会在创建一个以当前年月为子目录的结构。如图所示</p><p><img src="https://gitee.com/yoyhm/oss/raw/master/uPic/TNJnDw.png" alt="TNJnDw"></p><blockquote><p>如果之前已经建立好的文件想按照时间归类可以直接把文件拖到对应目录</p></blockquote><p>总结：可以看到第二种方法比第一种简单，且按照时间管理文件也比较方便。</p><h2 id="hexo-fluid-首页和文章等页面实现每天更换壁纸"><a href="#hexo-fluid-首页和文章等页面实现每天更换壁纸" class="headerlink" title="hexo.fluid 首页和文章等页面实现每天更换壁纸"></a>hexo.fluid 首页和文章等页面实现每天更换壁纸</h2><ol><li>首先在网上找到必应壁纸的接口<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="巨硬(必应)每日壁纸接口">[3]</span></a></sup>，网上有很多。</li><li>找到接口地址后，在<code>hexo.fluid</code>的配置中。修改这个地址</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">banner_img:</span> <span class="hljs-attr">https:</span><span class="hljs-comment">//static.zkqiang.cn/example.jpg</span><br></code></pre></td></tr></table></figure><h2 id="hexo-fluid-首页每次刷新显示不同的诗句"><a href="#hexo-fluid-首页每次刷新显示不同的诗句" class="headerlink" title="hexo.fluid 首页每次刷新显示不同的诗句"></a>hexo.fluid 首页每次刷新显示不同的诗句</h2><ol><li>参考<a href="https://www.jinrishici.com/">今日诗词</a>,通过<code>F12</code>获取其每次刷新的诗句接口。</li><li>在<code>hexo.fluid</code>的配置文件中，配置<code>slogan</code><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="hexo.fluid配置">[4]</span></a></sup></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">slogan:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">text:</span> <span class="hljs-string">这是一条</span> <span class="hljs-string">Slogan</span><br>    <span class="hljs-attr">api:</span><br>      <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;https://v1.hitokoto.cn/&quot;</span><br>      <span class="hljs-attr">method:</span> <span class="hljs-string">&quot;GET&quot;</span><br>      <span class="hljs-attr">headers:</span> &#123;&#125;<br>      <span class="hljs-attr">keys:</span> [<span class="hljs-string">&quot;hitokoto&quot;</span>]<br></code></pre></td></tr></table></figure><p>url: API 地址，必须返回的是一个 JSON 格式</p><p>method: 请求方法，可选 GET、POST、PUT</p><p>headers: 请求头，如果接口需要传一些验证的头部信息，在这里设置</p><p>keys: 从请求结果获取字符串的取值字段，程序会根据列表中的字段依次取值，最终需要获得到一个字符串</p><h2 id="使用hexo-admin管理后台-lt-span-class-”hint–top-hint–rounded”-aria-label-”hexo-admin-issue"><a href="#使用hexo-admin管理后台-lt-span-class-”hint–top-hint–rounded”-aria-label-”hexo-admin-issue" class="headerlink" title="使用hexo-admin管理后台 &lt;span class=”hint–top hint–rounded” aria-label=”hexo-admin issue"></a>使用hexo-admin管理后台 <sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote">&lt;span class=”hint–top hint–rounded” aria-label=”hexo-admin issue</h2><p>“&gt;[5]</span></a></sup></p><p>安装方法见<a href="https://github.com/jaredly/hexo-admin">hexo-admin</a>.<br>这里主要是看一下如何配置<code>hexo-admin</code>的文件</p><ul><li><code>hexo-admin</code>配置</li><li><code>hexo-admin</code>部署</li></ul><p><code>hexo-admin</code>只能在<code>_config.yml</code>中配置</p><p><code>hexo-admin</code>部署，需要配置<code>deployCommand</code>.</p><ol><li>首先在根目录创建一个文件<code>deploy.sh</code>，然后更<strong>改它的权限</strong>,这一步很重要，如果没有更改权限。<code>hexo-admin</code>无法执行该命令<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ touch <span class="hljs-keyword">deploy</span>.sh; chmod a+x <span class="hljs-keyword">deploy</span>.sh<br></code></pre></td></tr></table></figure></li></ol><p>接着在文件中写入下面的脚本，或者你可以自己定义脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/usr/bin/env sh</span><br>hexo deploy<br>and edit _config.yml:<br></code></pre></td></tr></table></figure><p>最后在<code>_config.yml</code>中配置<code>deployCommand</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">admin:<br>  deployCommand: &#x27;./hexo-deploy.sh&#x27;<br></code></pre></td></tr></table></figure><section class="footnotes"><h2>参考</h2><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%84%9A%E6%B3%A8">脚注</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://www.pianshen.com/article/81511649508/">hexo博客文章多了怎么管理</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://atlinker.cn/2019/07/28/bing.html">巨硬(必应)每日壁纸接口</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://hexo.fluid-dev.com/docs/guide/#slogan-%E6%89%93%E5%AD%97%E6%9C%BA">hexo.fluid配置</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://github.com/jaredly/hexo-admin/issues/70">hexo-admin issue</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>域名</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
